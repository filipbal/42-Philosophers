<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Philosophers Program Flow</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.2em;
        }

        .flow-section {
            margin: 40px 0;
            padding: 20px;
            border-radius: 15px;
            border-left: 5px solid;
        }

        .initialization {
            background: #e8f5e8;
            border-left-color: #27ae60;
        }

        .execution {
            background: #e3f2fd;
            border-left-color: #3498db;
        }

        .monitoring {
            background: #fff3e0;
            border-left-color: #f39c12;
        }

        .termination {
            background: #ffebee;
            border-left-color: #e74c3c;
        }

        .step {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 15px;
            background: rgba(255,255,255,0.7);
            border-radius: 10px;
            transition: transform 0.2s ease;
        }

        .step:hover {
            transform: translateX(10px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .step-number {
            background: #34495e;
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 20px;
            flex-shrink: 0;
        }

        .step-content h3 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 1.2em;
        }

        .step-content p {
            margin: 0;
            color: #7f8c8d;
            line-height: 1.4;
        }

        .code-snippet {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            font-size: 0.9em;
            overflow-x: auto;
        }

        .timeline {
            position: relative;
            margin: 30px 0;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 30px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #bdc3c7;
        }

        .timeline-item {
            position: relative;
            padding: 20px 20px 20px 70px;
            margin-bottom: 20px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: 20px;
            top: 25px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            border: 3px solid white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .philosopher-cycle {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .cycle-step {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .cycle-step:hover {
            transform: scale(1.05);
        }

        .cycle-step h4 {
            margin: 0 0 10px 0;
            font-size: 1.3em;
        }

        .test-case {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .test-case h3 {
            color: #495057;
            margin-top: 0;
        }

        .command {
            background: #343a40;
            color: #f8f9fa;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: monospace;
            margin: 10px 0;
        }

        .expected-output {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .critical {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üçù Philosophers Program Flow</h1>
            <p>Complete execution flow with thread synchronization</p>
        </div>

        <!-- Initialization Phase -->
        <div class="flow-section initialization">
            <h2>üöÄ Phase 1: Initialization</h2>
            
            <div class="step">
                <div class="step-number">1</div>
                <div class="step-content">
                    <h3>Argument Parsing</h3>
                    <p>Validate command line arguments and convert to integers</p>
                    <div class="code-snippet">parse_arguments(argc, argv, &args)</div>
                </div>
            </div>

            <div class="step">
                <div class="step-number">2</div>
                <div class="step-content">
                    <h3>Data Structure Initialization</h3>
                    <p>Initialize main data structure with arguments and set start time</p>
                    <div class="code-snippet">init_data(&data, &args)</div>
                </div>
            </div>

            <div class="step">
                <div class="step-number">3</div>
                <div class="step-content">
                    <h3>Mutex Creation</h3>
                    <p>Create mutexes for forks, printing, and death detection</p>
                    <div class="code-snippet">init_mutexes(&data) // Creates N fork mutexes + 2 control mutexes</div>
                </div>
            </div>

            <div class="step">
                <div class="step-number">4</div>
                <div class="step-content">
                    <h3>Philosopher Setup</h3>
                    <p>Initialize philosopher structures with IDs and shared data reference</p>
                    <div class="code-snippet">init_philosophers(&data)</div>
                </div>
            </div>
        </div>

        <!-- Execution Phase -->
        <div class="flow-section execution">
            <h2>‚ö° Phase 2: Thread Execution</h2>
            
            <div class="step">
                <div class="step-number">5</div>
                <div class="step-content">
                    <h3>Thread Creation</h3>
                    <p>Create one thread per philosopher + one monitor thread</p>
                    <div class="code-snippet">
for (i = 0; i < num_philos; i++)
    pthread_create(&philos[i].thread, NULL, philosopher_routine, &philos[i]);
pthread_create(&monitor_thread, NULL, monitor_death, data);
                    </div>
                </div>
            </div>

            <div class="step">
                <div class="step-number">6</div>
                <div class="step-content">
                    <h3>Philosopher Lifecycle</h3>
                    <p>Each philosopher enters the eat-sleep-think cycle</p>
                </div>
            </div>

            <div class="philosopher-cycle">
                <div class="cycle-step">
                    <h4>üçΩÔ∏è EAT</h4>
                    <p>Lock both forks, eat for time_to_eat ms, update last_meal_time</p>
                </div>
                <div class="cycle-step">
                    <h4>üò¥ SLEEP</h4>
                    <p>Sleep for time_to_sleep ms</p>
                </div>
                <div class="cycle-step">
                    <h4>ü§î THINK</h4>
                    <p>Think until next cycle (minimal time)</p>
                </div>
            </div>

            <div class="step">
                <div class="step-number">7</div>
                <div class="step-content">
                    <h3>Fork Acquisition Strategy</h3>
                    <p>Prevent deadlock with different pickup orders</p>
                    <div class="code-snippet">
// Odd philosophers: left ‚Üí right
// Even philosophers: right ‚Üí left
if (philo->id % 2 == 1) {
    lock(left_fork); lock(right_fork);
} else {
    lock(right_fork); lock(left_fork);
}
                    </div>
                </div>
            </div>
        </div>

        <!-- Monitoring Phase -->
        <div class="flow-section monitoring">
            <h2>üëÅÔ∏è Phase 3: Monitoring</h2>
            
            <div class="timeline">
                <div class="timeline-item">
                    <h3>Death Detection Loop</h3>
                    <p>Monitor thread checks every 1ms for philosopher deaths</p>
                    <div class="code-snippet">
while (!simulation_end) {
    check_philosopher_deaths(data);
    check_all_ate_enough(data);
    usleep(1000);
}
                    </div>
                </div>

                <div class="timeline-item">
                    <h3>Death Condition Check</h3>
                    <p>If (current_time - last_meal_time) >= time_to_die</p>
                    <div class="warning">
                        <strong>Critical:</strong> Death message must appear within 10ms of actual death
                    </div>
                </div>

                <div class="timeline-item">
                    <h3>Meal Count Tracking</h3>
                    <p>Stop simulation when all philosophers reach must_eat_count</p>
                </div>
            </div>
        </div>

        <!-- Termination Phase -->
        <div class="flow-section termination">
            <h2>üîö Phase 4: Termination</h2>
            
            <div class="step">
                <div class="step-number">8</div>
                <div class="step-content">
                    <h3>Simulation End Signal</h3>
                    <p>Set global flag to stop all philosopher threads</p>
                    <div class="code-snippet">set_simulation_end(data)</div>
                </div>
            </div>

            <div class="step">
                <div class="step-number">9</div>
                <div class="step-content">
                    <h3>Thread Cleanup</h3>
                    <p>Wait for all threads to complete using pthread_join</p>
                    <div class="code-snippet">
for (i = 0; i < num_philos; i++)
    pthread_join(philos[i].thread, NULL);
pthread_join(monitor_thread, NULL);
                    </div>
                </div>
            </div>

            <div class="step">
                <div class="step-number">10</div>
                <div class="step-content">
                    <h3>Resource Cleanup</h3>
                    <p>Destroy mutexes and free allocated memory</p>
                    <div class="code-snippet">cleanup_and_exit(&data, exit_code)</div>
                </div>
            </div>
        </div>

        <!-- Test Case Walkthrough -->
        <div class="test-case">
            <h3>üß™ Test Case Walkthrough: ./philo 4 310 200 100</h3>
            
            <div class="command">./philo 4 310 200 100</div>
            
            <p><strong>Setup:</strong> 4 philosophers, die in 310ms, eat for 200ms, sleep for 100ms</p>
            
            <div class="expected-output">
                <h4>Expected Timeline:</h4>
                <ul>
                    <li><strong>0ms:</strong> All philosophers start, even ones delay 1ms</li>
                    <li><strong>0-1ms:</strong> Philosophers 1,3 grab forks first</li>
                    <li><strong>1-2ms:</strong> Philosophers 2,4 attempt to grab forks</li>
                    <li><strong>0-200ms:</strong> First eating cycle</li>
                    <li><strong>200-300ms:</strong> Sleep cycle</li>
                    <li><strong>300-310ms:</strong> Critical window - must start eating again</li>
                </ul>
            </div>

            <div class="critical">
                <strong>Critical Point:</strong> If any philosopher can't acquire both forks by 310ms from their last meal start, they die. This tests the efficiency of your fork acquisition algorithm.
            </div>
        </div>

        <!-- Key Synchronization Points -->
        <div class="test-case">
            <h3>üîê Key Synchronization Points</h3>
            
            <div class="step">
                <div class="step-number">üç¥</div>
                <div class="step-content">
                    <h3>Fork Mutexes</h3>
                    <p>Each fork has its own mutex. Philosophers must acquire two adjacent forks to eat.</p>
                    <div class="code-snippet">pthread_mutex_lock(&data->forks[left_fork]);</div>
                </div>
            </div>

            <div class="step">
                <div class="step-number">üìù</div>
                <div class="step-content">
                    <h3>Print Mutex</h3>
                    <p>Protects console output to prevent message overlapping.</p>
                    <div class="code-snippet">pthread_mutex_lock(&data->print_mutex);</div>
                </div>
            </div>

            <div class="step">
                <div class="step-number">üíÄ</div>
                <div class="step-content">
                    <h3>Death Mutex</h3>
                    <p>Protects the simulation_end flag read/write operations.</p>
                    <div class="code-snippet">pthread_mutex_lock(&data->death_mutex);</div>
                </div>
            </div>
        </div>

        <!-- Common Pitfalls -->
        <div class="test-case">
            <h3>‚ö†Ô∏è Common Evaluation Pitfalls</h3>
            
            <div class="warning">
                <strong>Data Race:</strong> Messages appear incomplete or overlapped
                <br><em>Solution:</em> Always lock print_mutex before any printf
            </div>

            <div class="warning">
                <strong>Deadlock:</strong> All philosophers grab their left fork simultaneously
                <br><em>Solution:</em> Use different pickup orders for odd/even philosophers
            </div>

            <div class="critical">
                <strong>Late Death Detection:</strong> Death message appears >10ms after actual death
                <br><em>Solution:</em> Monitor thread checks every 1ms, not every death_time
            </div>

            <div class="warning">
                <strong>Memory Leaks:</strong> Mutexes not destroyed or memory not freed
                <br><em>Solution:</em> Implement proper cleanup_and_exit function
            </div>
        </div>

        <!-- Performance Tips -->
        <div class="test-case">
            <h3>üöÄ Performance Optimization Tips</h3>
            
            <ol>
                <li><strong>Precise Sleep:</strong> Use custom sleep function for accurate timing</li>
                <li><strong>Minimal Monitor Frequency:</strong> Check deaths every 1ms, not continuously</li>
                <li><strong>Early Exit Checks:</strong> Check simulation_end before expensive operations</li>
                <li><strong>Efficient Fork Indexing:</strong> Calculate left/right fork indices correctly</li>
            </ol>

            <div class="code-snippet">
// Your precise_sleep implementation
void precise_sleep(long duration) {
    long start = get_time_ms();
    while (get_time_ms() - start < duration) {
        if (duration - (get_time_ms() - start) > 10)
            usleep((duration - (get_time_ms() - start)) * 500);
        else
            usleep(100);
    }
}
            </div>
        </div>
    </div>
</body>
</html>